"use strict";var N=Object.create;var m=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,z=Object.prototype.hasOwnProperty;var a=(e,r)=>m(e,"name",{value:r,configurable:!0});var I=(e,r,s,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let n of A(r))!z.call(e,n)&&n!==s&&m(e,n,{get:()=>r[n],enumerable:!(t=y(r,n))||t.enumerable});return e};var S=(e,r,s)=>(s=e!=null?N(v(e)):{},I(r||!e||!e.__esModule?m(s,"default",{value:e,enumerable:!0}):s,e));Object.defineProperty(exports,"__esModule",{value:!0});var P=require("@mongodb-js/zstd"),q=require("hono/utils/compress");const Z="Cloudflare-Workers",g=["zstd","br","gzip","deflate"],B=/(?:^|,)\s*?no-transform\s*?(?:,|$)/i,k=1024,G=2,H=11,M=6,V=globalThis.navigator?.userAgent===Z,W=globalThis.Deno?.env?.get("DENO_DEPLOYMENT_ID")!==void 0;function $(e){const r=e.headers.get("Content-Type");return r&&q.COMPRESSIBLE_CONTENT_TYPE_REGEX.test(r)}a($,"shouldCompress");function x(e){const r=e.headers.get("Cache-Control");return!r||!B.test(r)}a(x,"shouldTransform");const F=import("brotli-wasm");let w;F.then(e=>{w=e});const X=import("node:zlib");let l;X.then(e=>{l=e}).catch(null);class T extends TransformStream{static{a(this,"ZstdCompressionStream")}constructor(r){super({async transform(s,t){t.enqueue(await P.compress(s,r))}})}}class L extends TransformStream{static{a(this,"BrotliCompressionStream")}constructor(r){const s=new w.CompressStream(r);super({transform(t,n){n.enqueue(s.compress(t,t.length).buf)}})}}class _{static{a(this,"ZlibCompressionStream")}readable;writable;constructor(r,s){let t;switch(r){case"br":{t=l.createBrotliCompress(s);break}case"gzip":{t=l.createGzip(s);break}case"deflate":{t=l.createDeflate(s);break}default:t=l.createDeflateRaw(s)}this.readable=new ReadableStream({async start(n){for await(const u of t.iterator())n.enqueue(u);n.close()}}),this.writable=new WritableStream({write:a(n=>t.write(n),"write"),close:a(()=>t.end(),"close")})}}const O=a(({encoding:e,encodings:r=[...g],threshold:s=k,zstdLevel:t=G,brotliLevel:n=H,zlibLevel:u=M,options:d={},filter:f}={})=>{e&&(r=[e]),d={...d,level:u};const E=r.find(p=>!g.includes(p));if(E)throw new Error(`Invalid compression encoding: ${E}`);return a(async function(o,R){await R();let h=o.res.body;if(!h||o.req.method==="HEAD"||o.res.headers.has("Content-Encoding"))return;const C=o.req.header("Accept-Encoding");if(!C)return;const i=r.find(D=>C.includes(D));if(!i)return;let b=Number(o.res.headers.get("Content-Length"));if(b&&b<s||!$(o.res)||!x(o.res))return;if(f!=null){if(!f(o))return}else if(W||V)return;let c;i==="zstd"?c=new T(t):l?c=new _(i,d):i==="br"?c=new L(n):c=new CompressionStream(i),o.res=new Response(h.pipeThrough(c),o.res),o.res.headers.delete("Content-Length"),o.res.headers.set("Content-Encoding",i)},"compress2")},"compress");exports.BrotliCompressionStream=L,exports.ZlibCompressionStream=_,exports.ZstdCompressionStream=T,exports.compress=O,exports.default=O;
