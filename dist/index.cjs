"use strict";var N=Object.create;var d=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,z=Object.prototype.hasOwnProperty;var a=(e,r)=>d(e,"name",{value:r,configurable:!0});var I=(e,r,t,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let n of A(r))!z.call(e,n)&&n!==t&&d(e,n,{get:()=>r[n],enumerable:!(s=y(r,n))||s.enumerable});return e};var b=(e,r,t)=>(t=e!=null?N(v(e)):{},I(r||!e||!e.__esModule?d(t,"default",{value:e,enumerable:!0}):t,e));Object.defineProperty(exports,"__esModule",{value:!0});var P=require("@mongodb-js/zstd"),q=require("hono/utils/compress");const Z="Cloudflare-Workers",S=["zstd","br","gzip","deflate"],B=/(?:^|,)\s*?no-transform\s*?(?:,|$)/i,k=1024,G=3,H=11,M=6,V=globalThis.navigator?.userAgent===Z,W=globalThis.Deno?.env?.get("DENO_DEPLOYMENT_ID")!==void 0;function $(e){const r=e.headers.get("Content-Type");return r&&q.COMPRESSIBLE_CONTENT_TYPE_REGEX.test(r)}a($,"shouldCompress");function x(e){const r=e.headers.get("Cache-Control");return!r||!B.test(r)}a(x,"shouldTransform");const F=import("brotli-wasm");let g;F.then(e=>{g=e});const X=import("node:zlib");let l;X.then(e=>{l=e}).catch(null);class w extends TransformStream{static{a(this,"ZstdCompressionStream")}constructor(r){super({async transform(t,s){s.enqueue(await P.compress(t,r))}})}}class T extends TransformStream{static{a(this,"BrotliCompressionStream")}constructor(r){const t=new g.CompressStream(r);super({transform(s,n){n.enqueue(t.compress(s,s.length).buf)}})}}class L{static{a(this,"ZlibCompressionStream")}readable;writable;constructor(r,t){let s;switch(r){case"br":{s=l.createBrotliCompress(t);break}case"gzip":{s=l.createGzip(t);break}case"deflate":{s=l.createDeflate(t);break}default:s=l.createDeflateRaw(t)}this.readable=new ReadableStream({async start(n){for await(const u of s.iterator())n.enqueue(u);n.close()}}),this.writable=new WritableStream({write:a(n=>s.write(n),"write"),close:a(()=>s.end(),"close")})}}const _=a(({encoding:e,encodings:r=[...S],options:t={},threshold:s=k,zstdLevel:n=G,brotliLevel:u=H,zlibLevel:O=M,filter:m}={})=>{e&&(r=[e]),t={...t,level:O};const f=r.find(E=>!S.includes(E));if(f)throw new Error(`Invalid compression encoding: ${f}`);return a(async function(o,R){await R();let p=o.res.body;if(!p||o.req.method==="HEAD"||o.res.headers.has("Content-Encoding"))return;const h=o.req.header("Accept-Encoding");if(!h)return;const i=r.find(D=>h.includes(D));if(!i)return;let C=Number(o.res.headers.get("Content-Length"));if(C&&C<s||!$(o.res)||!x(o.res))return;if(m!=null){if(!m(o))return}else if(W||V)return;let c;i==="zstd"?c=new w(n):l?c=new L(i,t):i==="br"?c=new T(u):c=new CompressionStream(i),o.res=new Response(p.pipeThrough(c),o.res),o.res.headers.delete("Content-Length"),o.res.headers.set("Content-Encoding",i)},"compress2")},"compress");exports.BrotliCompressionStream=T,exports.ZlibCompressionStream=L,exports.ZstdCompressionStream=w,exports.compress=_,exports.default=_;
